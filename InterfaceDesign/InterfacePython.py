#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Mar 23, 2024 03:43:56 PM EDT  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
#from tkinter.constants import * TODO see if useless
from tkinter import messagebox
import re
import threading
import os.path
import time
import numpy as np
import serial
import InterfacePython_support

#Modifié
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

_location = os.path.dirname(__file__)


_BGCOLOR = '#d9d9d9'
_FGCOLOR = '#000000'
_TABTG1 = 'black'
_TABFG2 = 'white'
_BGMODE = 'light'
_TABBG1 = '#d9d9d9'
_TABBG2 = 'gray40'


# units that can be used
unit_names = [
    "Gramme",
    "Lbs",
    "Newton",
    "Once"
]
# conversion rate in units per gram
unit_rates = [
    1,
    2.20462,
    9.80665,
    0.035274
]
# coins that can be used for counting or identifying
coin_names = [
    "1 cent",
    "2 cent",
    "10 cent",
    "20 cent",
    "1 dollar",
    "2 dollars"
]
# weights of each coin
coin_masses = [
    2.35,
    3.95,
    1.75,
    4.4,
    7,
    7.3
]
# max number of digits to allow in display
MAX_PRECISION = 3

#data ={'masse': 100, 'tension': 1.445, 'stable': True}

def position_tension(tension_ampli):
    """
    Conversion de la tension de l'ampli vers une position
    """
    c1 = 5813.9
    c2 = 198.24
    c3 = 0.60750
    
    tension_non_ampli = (tension_ampli/2.4) + 0.4 # TODO à voir, je pense que c'est different
    position = np.sqrt((c1/(tension_non_ampli - c3))**(2.0/3.0) - c2)
    return position

class Toplevel1:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''

        #Modifié====
        top.geometry("800x550")
        # top.minsize(120, 1)
        # top.maxsize(3076, 845)
        top.title("Interface de contrôle du prototype")
        top.configure(background="#d9d9d9")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="#000000")

        # Make the GUI not resizable
        top.resizable(0,0)

        self.top = top
        self.che86 = tk.IntVar()
        self.graph_choice = 0
        self.selected_coin_index = 0
        self.selected_unit_index = 0
        self.selected_precision = 0
        #Modifié

        self.masse = 0
        self.tension = 0
        self.is_stable = False

        port = '/dev/cu.usbmodem1201'  # remplacer avec le port série nécessaire
        baud_rate = 115200
        try:
            self.arduino = serial.Serial(port, baud_rate)
        except serial.SerialException:
            self.arduino = None
        self.x_temps = 0
        self.y_forces = 0
        self.y_positions = 0

        self.Labelframe3 = tk.LabelFrame(self.top)
        self.Labelframe3.place(x=260, y=158, height=389, width=530)
        self.Labelframe3.configure(relief='groove')
        self.Labelframe3.configure(font="-family {Segoe UI} -size 11 -weight bold")
        self.Labelframe3.configure(foreground="#000000")
        self.Labelframe3.configure(text='''Graphiques''')
        self.Labelframe3.configure(background="#d9d9d9")
        self.Labelframe3.configure(cursor="fleur")
        self.Labelframe3.configure(highlightbackground="#d9d9d9")
        self.Labelframe3.configure(highlightcolor="#000000")


        #Modifié======
        self.Listbox3 = tk.Listbox(self.Labelframe3)
        self.Listbox3.place(x=10, y=337, height=44, width=314
                , bordermode='ignore')
        self.Listbox3.configure(background="white")
        self.Listbox3.configure(disabledforeground="#a3a3a3")
        self.Listbox3.configure(font="TkFixedFont")
        self.Listbox3.configure(foreground="#000000")
        self.Listbox3.configure(highlightbackground="#d9d9d9")
        self.Listbox3.configure(highlightcolor="#000000")
        self.Listbox3.configure(selectbackground="#d9d9d9")
        self.Listbox3.configure(selectforeground="black")
        self.Listbox3.insert(tk.END, "Force en fonction du temps")
        self.Listbox3.insert(tk.END, "Position en fonction du temps")
        def on_selectgraph(event):
                selection = self.Listbox3.curselection()
                if(len(selection) == 1):
                    self.graph_choice = selection[0]
        self.Listbox3.bind("<<ListboxSelect>>", on_selectgraph)
        #=====



        self.Canvas1 = tk.Canvas(self.Labelframe3)
        self.Canvas1.place(x=10, y=24, height=307, width=513
                , bordermode='ignore')
        self.Canvas1.configure(background="#d9d9d9")
        self.Canvas1.configure(borderwidth="2")
        self.Canvas1.configure(highlightbackground="#d9d9d9")
        self.Canvas1.configure(highlightcolor="#000000")
        self.Canvas1.configure(insertbackground="#000000")
        self.Canvas1.configure(relief="ridge")
        self.Canvas1.configure(selectbackground="#d9d9d9")
        self.Canvas1.configure(selectforeground="black")

        #Modifié=====
        # Create a Matplotlib figure
        self.fig, self.ax = plt.subplots(figsize=(5, 3.1))
        self.ax.plot([1, 2, 3, 4], [1, 4, 2, 3], color='black', linewidth=1.5)
        plt.ticklabel_format(style='sci', axis='x', scilimits=(0,0))
        self.ax.set_xlabel('Indéterminé', fontsize=10)
        self.ax.set_ylabel('Indéterminé', fontsize=10)

        # Embed the Matplotlib plot into Tkinter canvas
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.Canvas1)
        self.fig.tight_layout()

        self.canvas.draw()
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill='x', expand=1)
        #========


        self.Labelframe2 = tk.LabelFrame(self.top)
        self.Labelframe2.place(x=260, y=52, height=105, width=530)
        self.Labelframe2.configure(relief='groove')
        self.Labelframe2.configure(font="-family {Segoe UI} -size 11 -weight bold")
        self.Labelframe2.configure(foreground="#000000")
        self.Labelframe2.configure(text='''Masse active''')
        self.Labelframe2.configure(background="#d9d9d9")
        self.Labelframe2.configure(highlightbackground="#d9d9d9")
        self.Labelframe2.configure(highlightcolor="#000000")

        self.Buttonaqui = tk.Button(self.Labelframe2)#, command=self.onClickAcqui) TODO reenable this button
        self.Buttonaqui.place(x=330, y=33, height=50, width=190, bordermode='ignore')

        self.Buttonaqui.configure(activebackground="#d9d9d9")
        self.Buttonaqui.configure(activeforeground="black")
        self.Buttonaqui.configure(background="#d9d9d9")
        self.Buttonaqui.configure(disabledforeground="#a3a3a3")
        self.Buttonaqui.configure(foreground="#000000")
        self.Buttonaqui.configure(highlightbackground="#d9d9d9")
        self.Buttonaqui.configure(highlightcolor="#000000")
        self.Buttonaqui.configure(text='''Acquisition''')


        #dexuière des deux listesbox ou la masse NOMBRE DE CHIFFRES APRES LA VIRGULE
        self.Listbox2 = tk.Listbox(self.Labelframe2)
        self.Listbox2.place(x=270, y=20, height=72, width=54
                , bordermode='ignore')
        self.Listbox2.configure(background="white")
        self.Listbox2.configure(disabledforeground="#a3a3a3")
        self.Listbox2.configure(font="TkFixedFont")
        self.Listbox2.configure(foreground="#000000")
        self.Listbox2.configure(highlightbackground="#d9d9d9")
        self.Listbox2.configure(highlightcolor="#000000")
        self.Listbox2.configure(selectbackground="#d9d9d9")
        self.Listbox2.configure(selectforeground="black")
        precision_options = [f"{opt} dec" for opt in range(MAX_PRECISION)]
        for opt in precision_options:
            self.Listbox2.insert(tk.END, opt)
        def on_selectVirgule(event2):
            selection = self.Listbox2.curselection()
            if len(selection) == 1:
                self.selected_precision = selection[0]
        self.Listbox2.bind("<<ListboxSelect>>", on_selectVirgule)

        #première des deux listesbox ou la masse UNITÉ
        self.Listbox1 = tk.Listbox(self.Labelframe2)
        self.Listbox1.place(x=210, y=20, height=72, width=54
                , bordermode='ignore')
        self.Listbox1.configure(background="white")
        self.Listbox1.configure(disabledforeground="#a3a3a3")
        self.Listbox1.configure(font="TkFixedFont")
        self.Listbox1.configure(foreground="#000000")
        self.Listbox1.configure(highlightbackground="#d9d9d9")
        self.Listbox1.configure(highlightcolor="#000000")
        self.Listbox1.configure(selectbackground="#d9d9d9")
        self.Listbox1.configure(selectforeground="black")
        self.Listbox1.insert(tk.END, "Gramme")
        self.Listbox1.insert(tk.END, "lbs")
        self.Listbox1.insert(tk.END, "Newton")
        self.Listbox1.insert(tk.END, "Once")
        def on_selectPoids(event):
            selection = self.Listbox2.curselection()
            if len(selection) == 1:
                self.selected_unit_index = selection[0]
        self.Listbox1.bind("<<ListboxSelect>>", on_selectPoids)

        #masse couleur set ou pas set
        self.Label2 = tk.Label(self.Labelframe2)
        self.Label2.place(x=10, y=24, height=71, width=178, bordermode='ignore')
        self.Label2.configure(activebackground="#d9d9d9")
        self.Label2.configure(activeforeground="black")
        self.Label2.configure(compound='left')
        self.Label2.configure(disabledforeground="#a3a3a3")
        self.Label2.configure(font="-family {Segoe UI} -size 12 -weight bold")
        self.Label2.configure(foreground="#000506")
        self.Label2.configure(highlightbackground="#d9d9d9")
        self.Label2.configure(highlightcolor="#000506")

        self.Labelframe1 = tk.LabelFrame(self.top)
        self.Labelframe1.place(x=10, y=53, height=393, width=240)
        self.Labelframe1.configure(relief='groove')
        self.Labelframe1.configure(font="-family {Segoe UI} -size 11 -weight bold")
        self.Labelframe1.configure(foreground="#000000")
        self.Labelframe1.configure(text='''Fonctions''')
        self.Labelframe1.configure(background="#d9d9d9")
        self.Labelframe1.configure(highlightbackground="#d9d9d9")
        self.Labelframe1.configure(highlightcolor="#000000")

        self.Button2 = tk.Button(self.Labelframe1, command=self.on_click_etalonner)
        self.Button2.place(x=13, y=77, height=36, width=207, bordermode='ignore')

        self.Button2.configure(activebackground="#d9d9d9")
        self.Button2.configure(activeforeground="black")
        self.Button2.configure(background="#d9d9d9")
        self.Button2.configure(disabledforeground="#a3a3a3")
        self.Button2.configure(foreground="#000000")
        self.Button2.configure(highlightbackground="#d9d9d9")
        self.Button2.configure(highlightcolor="#000000")
        self.Button2.configure(text='''Étalonner''')

        self.Button1 = tk.Button(self.Labelframe1, command=self.on_click_tare)
        self.Button1.place(x=13, y=33, height=36, width=207, bordermode='ignore')

        self.Button1.configure(activebackground="#d9d9d9")
        self.Button1.configure(activeforeground="black")
        self.Button1.configure(background="#d9d9d9")
        self.Button1.configure(disabledforeground="#a3a3a3")
        self.Button1.configure(foreground="#000000")
        self.Button1.configure(highlightbackground="#d9d9d9")
        self.Button1.configure(highlightcolor="#000000")
        self.Button1.configure(text='''Tarer''')

        self.Labelframe5 = tk.LabelFrame(self.Labelframe1)
        self.Labelframe5.place(x=10, y=285, height=95, width=220
                , bordermode='ignore')
        self.Labelframe5.configure(relief='groove')
        self.Labelframe5.configure(foreground="#000000")
        self.Labelframe5.configure(text='''Moyennage''')
        self.Labelframe5.configure(background="#d9d9d9")
        self.Labelframe5.configure(highlightbackground="#d9d9d9")
        self.Labelframe5.configure(highlightcolor="#000000")

        self.Message1 = tk.Message(self.Labelframe5)
        self.Message1.place(x=10, y=20, height=39, width=200
                , bordermode='ignore')
        self.Message1.configure(background="#d9d9d9")
        self.Message1.configure(foreground="#000000")
        self.Message1.configure(highlightbackground="#d9d9d9")
        self.Message1.configure(highlightcolor="#000000")
        self.Message1.configure(padx="1")
        self.Message1.configure(pady="1")
        self.Message1.configure(text='''Entrer un nombre entier de mesures désirées pour moyenner la masse.''')
        self.Message1.configure(width=200)

        self.Entry1 = tk.Entry(self.Labelframe5)
        self.Entry1.place(x=20, y=60, height=20, width=134, bordermode='ignore')
        self.Entry1.configure(background="white")
        self.Entry1.configure(disabledforeground="#a3a3a3")
        self.Entry1.configure(font="TkFixedFont")
        self.Entry1.configure(foreground="#000000")
        self.Entry1.configure(highlightbackground="#d9d9d9")
        self.Entry1.configure(highlightcolor="#000000")
        self.Entry1.configure(insertbackground="#000000")
        self.Entry1.configure(selectbackground="#d9d9d9")
        self.Entry1.configure(selectforeground="black")

        self.Labelframe4 = tk.LabelFrame(self.Labelframe1)
        self.Labelframe4.place(x=10, y=120, height=165, width=220
                , bordermode='ignore')
        self.Labelframe4.configure(relief='groove')
        self.Labelframe4.configure(foreground="#000000")
        self.Labelframe4.configure(text='''Comptage de pièces''')
        self.Labelframe4.configure(background="#d9d9d9")
        self.Labelframe4.configure(highlightbackground="#d9d9d9")
        self.Labelframe4.configure(highlightcolor="#000000")

        self.Checkbutton1 = tk.Checkbutton(self.Labelframe4)
        self.Checkbutton1.place(x=10, y=20, height=25, width=171
                , bordermode='ignore')
        self.Checkbutton1.configure(activebackground="#d9d9d9")
        self.Checkbutton1.configure(activeforeground="black")
        self.Checkbutton1.configure(anchor='w')
        self.Checkbutton1.configure(background="#d9d9d9")
        self.Checkbutton1.configure(compound='left')
        self.Checkbutton1.configure(disabledforeground="#a3a3a3")
        self.Checkbutton1.configure(foreground="#000000")
        self.Checkbutton1.configure(highlightbackground="#d9d9d9")
        self.Checkbutton1.configure(highlightcolor="#000000")
        self.Checkbutton1.configure(justify='left')
        self.Checkbutton1.configure(text='''Activer la fonctionnalité''')
        self.Checkbutton1.configure(variable=self.che86)

        #en dessous d'activité la fonctionnalité
        self.Listbox4 = tk.Listbox(self.Labelframe4)
        self.Listbox4.place(x=10, y=50, height=103, width=84
                , bordermode='ignore')
        self.Listbox4.configure(background="white")
        self.Listbox4.configure(disabledforeground="#a3a3a3")
        self.Listbox4.configure(font="TkFixedFont")
        self.Listbox4.configure(foreground="#000000")
        self.Listbox4.configure(highlightbackground="#d9d9d9")
        self.Listbox4.configure(highlightcolor="#000000")
        self.Listbox4.configure(selectbackground="#d9d9d9")
        self.Listbox4.configure(selectforeground="black")
        for coin in coin_names:
            self.Listbox4.insert(tk.END, coin)
        def on_selectnbrpiece(evenement):
            selection = self.Listbox4.curselection()
            if(len(selection) == 1):
                self.selected_coin_index = selection[0]
        self.Listbox4.bind("<<ListboxSelect>>", on_selectnbrpiece)
                

        self.Label2_1 = tk.Label(self.Labelframe4)
        self.Label2_1.place(x=100, y=50, height=101, width=98
                , bordermode='ignore')
        self.Label2_1.configure(activebackground="#d9d9d9")
        self.Label2_1.configure(activeforeground="black")
        self.Label2_1.configure(compound='left')
        self.Label2_1.configure(disabledforeground="#a3a3a3")
        self.Label2_1.configure(font="-family {Segoe UI} -size 12 -weight bold")
        self.Label2_1.configure(foreground="#000506")
        self.Label2_1.configure(highlightbackground="#d9d9d9")
        self.Label2_1.configure(highlightcolor="#000506")
        def on_checkbox_click():
                if self.che86.get():
                        self.Label2_1.configure(background="#f9040b")
                        self.Label2_1.configure(text= 0)
                else:
                        self.Label2_1.configure(background="gray")
                        self.Label2_1.configure(text= '')
                        
        self.Checkbutton1.configure(variable=self.che86, command= on_checkbox_click)


        self.Label1 = tk.Label(self.top)
        self.Label1.place(x=-4, y=0, height=51, width=804)
        self.Label1.configure(activebackground="#d9d9d9")
        self.Label1.configure(activeforeground="#f5f5f5")
        self.Label1.configure(background="#98cc91")
        self.Label1.configure(compound='left')
        self.Label1.configure(disabledforeground="#a3a3a3")
        self.Label1.configure(font="-family {Segoe UI} -size 14 -weight bold")
        self.Label1.configure(foreground="#000000")
        self.Label1.configure(highlightbackground="#d9d9d9")
        self.Label1.configure(highlightcolor="#000000")
        self.Label1.configure(text='''Balance app''')

        
        self.acquisition_thread = threading.Thread(target=self.read_data_and_update) # used to fetch data in the background
        self.acquisition_thread.start()

#Modifié=====
        
    def send_tare_command(self):
        """
        envoie 't' à l'arduino: la commande de tare
        """
        command = "t"
        if not self.arduino:
            return
        self.arduino.write(bytearray(str(command), 'utf-8'))

    def send_calib_command(self, A, B):
        """
        envoie 'c [Constante A] [Constante B]' à l'arduino: la commande d'étalonnage et ses constantes
        """
        command = f"c {A} {B}"
        if not self.arduino:
            return
        self.arduino.write(bytearray(str(command), 'utf-8'))

    def on_click_tare(self):
        """Fonction qui est appelé lorsqu'on click sur 'tare'"""
        self.send_tare_command()

    def on_click_etalonner(self):
        messagebox.showinfo("Étape 1", "Poser rien sur la balance")
        #ampV1 = self.tensionAmp;
        messagebox.showinfo("Étape 2", "Poser 1g sur la balance")
        messagebox.showinfo("Étape 3", "Poser 2g sur la balance")
        messagebox.showinfo("Étape 4", "Poser 10g sur la balance")
        messagebox.showinfo("Étape 5", "Poser 20g sur la balance")
        #ampV2 = self.tensionAmp;
        #calibConstA = 20.0 / (ampV2 - ampV1);
        #calibConstB = -ampV1 * calibConstA;
        messagebox.showinfo("Étape 6", "Poser 50g sur la balance")
        messagebox.showinfo("Étalonnage terminé", "L'étalonnage à été effectué avec success")

    def on_click_acqui(self):
        pass # useless
    
    def parse_arduino_msg(self, data_txt):
        """
        Retourne un dictionaire des données qui se trouve dans le message d'arduino
        format: {"masse":masse, "tension":tension, "is_stable":is_stable}
        """
        pattern = r"masse:(.+),tension:(.+),stable:(.+)"
        match = re.search(pattern, data_txt)

        # If match is found, extract values and return them
        if match:
            masse = float(match.group(1))
            tension = float(match.group(2))
            is_stable = match.group(3)=='1'
            return {"masse":masse, "tension":tension, "is_stable":is_stable}
        return None

    def read_latest_line(self):
        """
        Lit toutes les données provenantes de l'arduino et retourne la dernière ligne.
        Utile si l'arduino envoie les données plus rapidement que le PC peut les lire.
        """
        last_line = None
        data = self.arduino.read_all().decode().strip()  # Read all available data and decode it
        if data:
            lines = data.split('\n')  # Split data into lines
            last_line = lines[-1]  # Get the last line
        return last_line
    
    def read_data_and_update(self):
        """
        Lit les données de l'arduino et met à jour l'interface
        """
        self.y_forces = []
        self.y_positions = []
        self.x_temps = []
        t = 0
        dt = 20*10**-3 # l'arduino update à chaque 20 ms
        while(True):
            if not self.arduino:
                  continue
            data_txt = self.read_latest_line()
            data = self.parse_arduino_msg(data_txt)
            if not data:
                 continue
            self.masse = data["masse"]
            self.tension = data["tension"]
            self.is_stable = data["is_stable"]
            if self.is_stable is True:
                    self.Label2.configure(background="green")
            else:
                    self.Label2.configure(background="red")
            self.Label2.configure(text=str(self.masse))#modifié
            
            t += dt
            self.x_temps.append(t)
            force = float(self.masse)*9.806
            self.y_forces.append(force)
            pos = position_tension(float(self.tension))
            self.y_positions.append(pos)

            if(len(self.x_temps) > 300):
                self.x_temps.pop(0)
                self.y_forces.pop(0)
                self.y_positions.pop(0)

            # comptage de pièces
            if self.che86.get() == 1:
                nombrepiece = self.masse//coin_masses
                self.Label2_1.configure(text=nombrepiece)
            
            # unitées
            mass_converted = self.masse * unit_rates[self.selected_unit_index]
            self.Label2.configure(text=str(round(mass_converted, self.selected_precision)))

            self.update_graph()


    def update_graph(self):
        """
        Met à jour le graphique Matplotlib
        """
        self.ax.clear()
          
        if  self.graph_choice == 0:
            x, y = self.x_temps, self.y_forces
            
        elif self.graph_choice == 1:
            x, y = self.x_temps, self.y_positions
        else:
            x, y = [0], [0]
        
        self.ax.plot(x, y, color='black', linewidth=1.5)
        plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
        plt.ticklabel_format(style='sci', axis='x', scilimits=(0,0))
        # self.ax.spines['top'].set_visible(False)
        # self.ax.spines['right'].set_visible(False)

        plt.grid(True, which='both', linestyle='--', alpha=0.7, linewidth=0.5)
        
        if self.graph_choice == 0:
        #     self.ax.set_xlim(min(x), max(x))
        #     self.ax.set_ylim(min(y), max(y))
            self.ax.set_xlabel('temps [s]', fontsize=10)
            self.ax.set_ylabel('Force [N]', fontsize=10)
            
        elif self.graph_choice == 1:
        #     self.ax.set_xlim(min(x), max(x))
        #     self.ax.set_ylim(min(y), max(y))
            self.ax.set_xlabel('temps [s]', fontsize=10)
            self.ax.set_ylabel('position [mm]', fontsize=10)
            
        else:
        #     self.ax.set_xlim(min(x), max(x))
        #     self.ax.set_ylim(min(y), max(y))
            self.ax.set_xlabel('Indéterminé', fontsize=10)
            self.ax.set_ylabel('Indéterminé', fontsize=10)
        
        self.canvas.draw()
#======

def start_up():
    """
    Appelé lors du début du programe
    """
    InterfacePython_support.main()

if __name__ == '__main__':
    InterfacePython_support.main()




